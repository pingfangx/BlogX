# 结果

    /**
     * 先初始化父类的 static
     * parent static field
     * 静态字段和静态化按源文件的声明顺序
     * parent static initial block
     * 再子类的静态字段
     * child static field
     * child static initial block
     * 父类的普通字段
     * parent field
     * parent initial block
     * 父类构造函数
     * parent constructor
     * 子类的普通字段
     * child field
     * child initial block
     * 子类构造函数
     * child constructor
     * 静态类只有使用时才初始化
     * child inner
     */
     
# 分析
    静态字段的初始化位于 static <clinit>()V
    暂不知道从哪里调用，难道是 java/lang/Object.<init> ()V
    所以静态字段在普通字段之前初始化。
    
    构造函数的初始化位于普通字段的初始化之后，
    为什么子类的普通字段初始化位于父类的构造函数之后
    因为普通字段的初始化和构造函数都是位于 public <init>()V 中
    而子类的 public <init>()V 是先调用父类的 <init>()V
    
    ALOAD 0
    INVOKESPECIAL com/pingfangx/study/book1/chapter05/InitialOrderTest$ParentClass.<init> ()V