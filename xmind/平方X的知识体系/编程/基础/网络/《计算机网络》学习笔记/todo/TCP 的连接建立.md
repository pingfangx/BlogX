# 00 前言
之前一直觉得是一块非常难的内容，但其实在书中仅有一小节，不到两页内容。

要了解这一部分内容，需要先掌握 TCP 报文段的首部格式  
尤其是
* 序号
* 确认号
* ACK
* SYN
* FIN

服务器进程建立传输控制块 TCB，准备接收客户进程的连接请求，服务器处于 LISTEN 状态  
客户进程也首先创建 TCB

# 01 客户向服务器发出连接请求报文段
在 5.5 TCP 报文段的首部格式中有介绍
> 同步 SYN 在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。  
> 对方若同意建立连接，则应在响应的报文段中使用 SYN = 1 和 ACK = 1。  
> 因此 SYN = 1 就表示这是一个连接请求或连接接受报文。

从这几点，我们知道
* 发送的 TCP 连接请求报文段，将首部中的 SYN 位置为 1
* 请求报文段 SYN = 1,seq = x  
SYN 是同步的意思，要同步的内容是序号，因此要选择一个初始序号 seq = x  
TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗一个序号  
消耗序号可以理解为，接收端认为确认了一个序号的数据，它返回的 ACK 要为 x + 1
* TCP 客户进程从 CLOSE 进入 SYN-SENT 状态

# 02 服务器向客户发送确认报文段
* 服务器收到连接请求报文段后，如果同意建立连接，则向客户发送确认  
如果不同意怎么办，在 TCP 报文段的首部格式中有介绍，可以将 RST 置为 1 拒绝打开一连接，实际是否是这样实现的，待查
* 确认报文段 SYN = 1,ACK = 1,seq = y,ack = x + 1  
基于前面的介绍，SYN 用来同步序号，所以报务端也会选择一个初始序号 y  
ACK 表示确认，仅当 ACK = 1 时确认号字段才有效，会了同步序号，这里要指定确认号字段。  
根据确认号的规定，表示期望收到对方下一个报文段的第一个数据字节的序号。  
正确接收了客户发送的序号 x ，所以确认号为 x + 1
* 服务器进程进入 SYN-RCVD 状态

# 03 客户收到确认报文段后，还要向服务器发送确认报文段
* 确认报文段 ACK = 1,ack = y + 1,seq = x + 1  
TCP 的标准规定，ACK 报文段可以携带数据，但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1  
这里是区别于前面所述的 SYN 报文段不能携带数据，但要消耗一个序号
* 客户进入 ESTABLISHED 状态
* 服务器收到确认报文段后，也进入 ESTABLISHED 状态

## 第三次握手不再需要 SYN
请求报文段是 SYN = 1 用来同步序号，通过 ACK 确认报文段确认。  
报务器已经返回 ACK ，不再需要 SYN  
报务器也可以将报文段拆分为两个报文段。一个确认报文段 ACK = 1,ack = x + 1，然后再发送同步报文段 SYN = 1 ,seq =y

## 为什么客户端还要再发送一次确认
为了防止已失效的连接报文段突然又传送到服务器

考虑客户发出第一个连接请求，长时间滞留。然后重传建立连接并断开。  
然后服务器才收到了第一个连接请求，于是向客户发送确认报文段。  
如果这种情况服务器就认为连接已经建立，就会一直等待客户发来数据，而实际客户并没有再发送建立连接的请求，所以会丢失确认请求。  
为了解决这种情况，第三次握手的情况下，客户端不发出确认，服务器未收到确认，就不会建立连接。