# 00 断开前断态
客户与服务器都处于 ESTABLISHED 状态

# 01 客户向服务器发送连接释放报文段，并停止发送，主动关闭 TCP 连接
* FIN = 1,seq = u  
前面已经介绍过，FIN 用来释放一个连接  
TCP 规定 FIN 报文段即使不携带数据，它也消耗一个序号
* 客户进入 FIN-WAIT-1 状态，等待服务器确认

# 02 服务器收到释放报文段后发出确认
* ACK = 1,seq=v,ack = u + 1  
确认是确认收到了序号 u 所以确认号为 u + 1
* 服务器进入 CLOSE-WAIT 状态
* TCP 服务器进程这时应通知高层应用程序，客户到服务器方向的连接释放了，此时 TCP 连接处理半关闭状态  
客户没有数据要发送到服务器了，但服务器可能有要发送的数据，客户仍要接收  
服务器到客户的连接并未关闭，可能会持续一段时间
* 客户收到来自服务器的确认后，进入 FIN-WAIT-2 状态，等待服务器发出的连接释放报文段

# 03 服务器发出连接释放报文段
如果服务器没有要向客户发送的数据，服务器的应用进程就通知 TCP 释放链接。
* FIN = 1,ACk = 1,seq = w,ack = u + 1  
上一次发送确认报文段时，seq = v，因为在半关闭状态服务器可能又发送了一些数据  
ack 与上一次发送的确认号相同，因为没有再接到客户的任何数据
* 服务器进入 LAST-ACK 状态

# 04 客户发送确认报文段
* ACK = 1,seq = u + 1,ack = w + 1  
因为收到的释放报文段序号为 w，所以确认号为 w + 1  
而序号因为 FIN 报文段要消耗一个序号，所以为 u + 1
* 客户进入 TIME-WAIT 状态  
TCP 还没有释放，必须经过时间等待计时器设置的时间 2MSL 后，客户才进入 CLOSE 状态

## 为什么 TIME-WAIT 要等待 2MSL
* 为了保证客户发送的最后一个 ACk 报文段能够到达服务器  
如果服务器未收到确认，服务器会重传 FIN+ACK 报文段，然后客户重传确认报文段，并重新启动 2MSL 计时器
* 为了防止已失效的连接请求报文出现在本连接中

除了时间等待计时器外，TCP 还设有一个保活计时器