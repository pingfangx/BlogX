数据结构这书也太懂了，我真的曾经看过这本书吗？

R:
* [Dijkstra算法原理](https://blog.csdn.net/yalishadaa/article/details/55827681)
* [戴克斯特拉算法](https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95)

> 边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到从 s 到 u 的路径尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比当前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。

> 算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合S初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。

简单示例

    A -> B 5
    A -> C 30
    B -> C 20
    
    初始时 S 中包含 d[c]=0
    Q 中则有 d[a]=30,d[b]=20
    
    选出 Q 中最短的 d[b]=20 表示 b 到 c 最短是 20
    将 d[b] 加入 S，从 Q 中移除 d[b]
    更新 Q
    Q 中还剩 d[a]=30，表示原本 a 到 c 最短为 30，此时移出去 d[b]=20
    b 也连通 a，且 w(b,a)=5
    d[b]+w(b,a)=25 < d[a]=30
    说明，c 先到 b 再到 a，距离比 c 直接到 a 要短。  
    于是装饰 d[a] 更新为 25
    最后将 d[a] 移到 S 中，结束。