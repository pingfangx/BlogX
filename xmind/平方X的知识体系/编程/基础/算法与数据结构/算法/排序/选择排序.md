# 算法概述

[选择排序](https://zh.wikipedia.org/zh-hans/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)
内层循环只选择位置，循环结束才交换

    i∈[0,n-1)
        min=i
        j∈[i+1,n)
            cmp a[min],a[j]->min
        swap a[i],a[min]
	
    def sort(self, a: List) -> List:
        for i in range(len(a)):
            t = i
            for j in range(i, len(a)):
                if a[j] < a[t]:
                    t = j
            if i != t:
                # 交换
                a[i], a[t] = a[t], a[i]
        return a



# 时间复杂度
视比较作为基本操作  
比较次数 n*(n-1)/2  
交换次数 0(有序) 到 n-1 (倒序)


O(n^2)

## 平均情况
O(n^2)

## 最坏情况
O(n^2)

## 最好情况
O(n^2)


# 空间复杂度
O(1)

# 稳定性
不稳定  
因为是将较小的交换到最前  
如果有两个相等的值，可能在交换时将前者移到后面  
而后者与较小时交换时，无法确定交换到哪里

# 备注
交换次数较少.
> 交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多， n 值较小时，选择排序比冒泡排序快。

> 原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。