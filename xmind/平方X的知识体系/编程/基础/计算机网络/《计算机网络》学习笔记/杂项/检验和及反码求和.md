# 伪首部
> The pseudo  header  conceptually prefixed to the UDP header contains the source  address,  the destination  address,  the protocol,  and the  UDP length.

> The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.  
> This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.
# 反码求和
反码求和最早出现于 4.2.5 IP 数据报的格式  
在 1.(10) 首部检验和底部有介绍

>注:两个数进行二进制反码求和的运算很简单,它的规则是从低位到高位逐列进行计算。  
> 0和0相加是0, 0和1相加是1,1和1相加是0但要产生一个进位1,加到下一列  
> 若最高位相加后产生进位,则最后得到的结果要加1
> 请注意,反码 (one's complement )和补码(two's complement)是不一样的


接下来又在 5.2.2 UDP 的首部格式  
中再次给出详细示例，为了验证示例，加深理解，尝试验算了一遍。  

但是由于自己写的算法原因，以及对反码求和不太理解的原因，折腾了很久

    
# 查找二进制反码求和的说明

最后确定 wiki 为

[Transmission Control Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)

[Error detection](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Error_detection)

[Checksum computation](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation)

[Signed number representations](https://en.wikipedia.org/wiki/Signed_number_representations)

[one's complement arithmetic](https://en.wikipedia.org/wiki/Signed_number_representations#Ones'_complement)

所以最后确定的部骤为
## 二进制反码求和规则
* 从低位向高位，按位求和
* 考虑进位
* 如果最高位进位，加到最低位

## 求检验和步骤
* 将数据划分为 16 位字的序列
* 将检验和字段置 0
* 依次按二进制反码求和规则累加  
第 1 个序列与第 2 个序列求和，结果再与第 3 个序列求和
* 最后结果取反码
* 填入检验和

# 示例
感谢
[二进制反码求和运算](https://www.cnblogs.com/jcchan/p/10400504.html)
给出了图方便我比对哪里算错了
![](https://img2018.cnblogs.com/blog/1330246/201902/1330246-20190219133410408-1352924495.jpg)

源码位于 udp_check_sum.py
输出


    计算之前
     10011001    00010011
     00001000    01101000
     10101011    00000011
     00001110    00001011
     00000000    00010001
     00000000    00001111
     00000100    00111111
     00000000    00001101
     00000000    00001111
     00000000    00000000
     01010100    01000101
     01010011    01010100
     01001001    01001110
     01000111    00000000

    第 1 行
     10011001    00010011

    加上第 2 行
     10011001    00010011
    +00001000    01101000
    =10100001    01111011

    加上第 3 行
     10100001    01111011
    +10101011    00000011
    =01001100    01111111

    加上第 4 行
     01001100    01111111
    +00001110    00001011
    =01011010    10001010

    加上第 5 行
     01011010    10001010
    +00000000    00010001
    =01011010    10011011

    加上第 6 行
     01011010    10011011
    +00000000    00001111
    =01011010    10101010

    加上第 7 行
     01011010    10101010
    +00000100    00111111
    =01011110    11101001

    加上第 8 行
     01011110    11101001
    +00000000    00001101
    =01011110    11110110

    加上第 9 行
     01011110    11110110
    +00000000    00001111
    =01011111    00000101

    加上第 10 行
     01011111    00000101
    +00000000    00000000
    =01011111    00000101

    加上第 11 行
     01011111    00000101
    +01010100    01000101
    =10110011    01001010

    加上第 12 行
     10110011    01001010
    +01010011    01010100
    =00000110    10011111

    加上第 13 行
     00000110    10011111
    +01001001    01001110
    =01001111    11101101

    加上第 14 行
     01001111    11101101
    +01000111    00000000
    =10010110    11101101
    按二进制反码求和为
    10010110    11101101
    求反码得到检验和为
    01101001    00010010
    在 18 处填入检验和，重新计算

    计算之前
     10011001    00010011
     00001000    01101000
     10101011    00000011
     00001110    00001011
     00000000    00010001
     00000000    00001111
     00000100    00111111
     00000000    00001101
     00000000    00001111
     01101001    00010010
     01010100    01000101
     01010011    01010100
     01001001    01001110
     01000111    00000000

    第 1 行
     10011001    00010011

    加上第 2 行
     10011001    00010011
    +00001000    01101000
    =10100001    01111011

    加上第 3 行
     10100001    01111011
    +10101011    00000011
    =01001100    01111111

    加上第 4 行
     01001100    01111111
    +00001110    00001011
    =01011010    10001010

    加上第 5 行
     01011010    10001010
    +00000000    00010001
    =01011010    10011011

    加上第 6 行
     01011010    10011011
    +00000000    00001111
    =01011010    10101010

    加上第 7 行
     01011010    10101010
    +00000100    00111111
    =01011110    11101001

    加上第 8 行
     01011110    11101001
    +00000000    00001101
    =01011110    11110110

    加上第 9 行
     01011110    11110110
    +00000000    00001111
    =01011111    00000101

    加上第 10 行
     01011111    00000101
    +01101001    00010010
    =11001000    00010111

    加上第 11 行
     11001000    00010111
    +01010100    01000101
    =00011100    01011101

    加上第 12 行
     00011100    01011101
    +01010011    01010100
    =01101111    10110001

    加上第 13 行
     01101111    10110001
    +01001001    01001110
    =10111000    11111111

    加上第 14 行
     10111000    11111111
    +01000111    00000000
    =11111111    11111111
    按二进制反码求和为
    11111111    11111111
    每一位都是1，检验成功