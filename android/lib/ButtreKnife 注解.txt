Q:
* 注解的相关知识点
* 注解是如何被解析的
* ButterKnife 的注解是如何实现的


# 0x01 注解
注解在 tutorial 里面就有介绍。

# 0x02 实现一个自定义的注解
注意指定 Retention 和 Target，不指定获取失败

遍历字段，如果找到了注解，则执行 findViewById 然后给字段赋值

    fun parseAnnotation(view: View) {
        val clazz = MainActivity::class.java
        for (field in clazz.declaredFields) {
            val annotation: BindView? = field.getAnnotation(BindView::class.java)
            annotation?.let {
                Log.d("xx", "field is ${field.name},annotation is ${annotation.id}")
                bindView(field, annotation.id)
            }
        }
    }

    private fun bindView(field: Field, id: Int) {
        val view: View? = findViewById(id)
        view?.let {
            val clazz = field.type
            try {
                val cast = clazz.cast(view)
                field.set(this, cast)
                toast("绑定成功")
            } catch (e: ClassCastException) {
                toast("类型转换失败")
            } catch (e: Exception) {
                e.printStackTrace()
                toast("绑定失败")
            }
        }
    }

# 0x03 ButterKnife 的注解是如何实现的
[butterknife-compiler](https://github.com/JakeWharton/butterknife/tree/master/butterknife-compiler)


    @AutoService(Processor.class)
    public final class ButterKnifeProcessor extends AbstractProcessor {

      @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
        Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);

        for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {
          TypeElement typeElement = entry.getKey();
          BindingSet binding = entry.getValue();

          JavaFile javaFile = binding.brewJava(sdk, debuggable);
          try {
            javaFile.writeTo(filer);
          } catch (IOException e) {
            error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage());
          }
        }

        return false;
      }

    }
    
    通过 butterknife.compiler.ButterKnifeProcessor#findAndParseTargets 查找并解析目标，然后写入
    
      private Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {
        Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();
        Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();
        ...

        // Process each @BindViews element.
        for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
          // we don't SuperficialValidation.validateElement(element)
          // so that an unresolved View type can be generated by later processing rounds
          try {
            parseBindViews(element, builderMap, erasedTargetNames);
          } catch (Exception e) {
            logParsingError(element, BindViews.class, e);
          }
        }

        // Process each annotation that corresponds to a listener.
        for (Class<? extends Annotation> listener : LISTENERS) {
          findAndParseListener(env, listener, builderMap, erasedTargetNames);
        }
        ...
        return bindingMap;
      }
      
      通过 getElementsAnnotatedWith 获取所有的 Element ,然后迭代
      
      private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
          Set<TypeElement> erasedTargetNames) {
        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();
        //校验
        if (hasError) {
          return;
        }

        // Assemble information on the field.
        int id = element.getAnnotation(BindView.class).value();
        BindingSet.Builder builder = builderMap.get(enclosingElement);
        Id resourceId = elementToId(element, BindView.class, id);
        ...

        String name = simpleName.toString();
        TypeName type = TypeName.get(elementType);
        boolean required = isFieldRequired(element);

        builder.addField(resourceId, new FieldViewBinding(name, type, required));

        // Add the type-erased version to the valid binding targets set.
        erasedTargetNames.add(enclosingElement);
      }
      
      //写入方法
      butterknife.compiler.BindingSet#brewJava
      然后使用了库 javapoet
      
简要分析了一下，详细的已有分析[顾修忠.《深入理解ButterKnife源码并掌握原理（一)》](https://blog.csdn.net/ta893115871/article/details/52497297)


TODO 还剩下一个知识点，如何开发一个库，及开发一个插件。